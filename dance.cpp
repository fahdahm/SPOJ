// 2021-09-??
// Steps to solve the problem:
// 1) Notice that the group generated by the R and S operations is
//    isomorphic to the modular group, where R corresponds to the function
//    z -> -1/z, S corresponds to z -> z + 1, and the group operation is
//    function composition. This is hard. I only managed to learn this by
//    reading a hint that I found online.
// 2) Read about the properties of the modular group, in particular that SR
//    (which I'm using to mean S followed by R, not S composed with R, in order
//    to be consistent with the problem statement) has order 3. Write T = SR,
//    so RR = TTT = I. Further, read that the modular group is the free product
//    of the C_2 subgroup generated by R and the C_3 subgroup generated by T.
// 3) Conclude that a simple algorithm exists. First, rewrite the input string
//    using the rule S = TR. Then, reduce it using the rules RR = TTT = I.
//    This describes the "tangled" state specified by the input. Now, we have
//    to untangle it by appending R and TR to the right repeatedly (TR counts
//    as one operation, since it's S). It's pretty easy to figure out which:
//    if the string ends in R, then do R (and the two R's cancel). If the
//    string ends in T, then do TR and if there are 3 T's in a row, cancel
//    them. Repeat until the string is empty (identity element).
// 4) Whoops! That doesn't quite work. We need to remember one more detail:
//    RT at the beginning of the string can be cancelled, because it fixes 0
//    (the untangled initial state). TTR also fixes 0 and can be cancelled at
//    the beginning, but it turns out to be easier to just insert RT at the
//    beginning whenever the string starts with TT: in other words
//    TT -> RTTT -> R.
#include <deque>
#include <iostream>
#include <string>
using namespace std;
void apply_move(deque<char>& state, char c) {
    state.push_back(c);
  top:
    const int l = state.size();
    if (l >= 2 && state[0] == 'R') {
        // cancel RR and RT at the beginning of the string
        state.erase(state.begin(), state.begin() + 2);
        goto top;
    }
    if (l >= 2 && state[0] == 'T' && state[1] == 'T') {
        // replace TT with R at the beginning of the string
        state.pop_front();
        state[0] = 'R';
        goto top;
    }
    if (l >= 2 && state[l - 1] == 'R' && state[l - 2] == 'R') {
        // cancel RR at the end of the string
        state.resize(l - 2);
        goto top;
    }
    if (l >= 3 && state[l - 1] == 'T' &&
        state[l - 2] == 'T' && state[l - 3] == 'T') {
        // cancel TTT at the end of the string
        state.resize(l - 3);
        goto top;
    }
}
void do_testcase() {
    string s;
    getline(cin, s);  // # of moves, which is redundant
    getline(cin, s);
    deque<char> state;
    for (const char c : s) {
        if (c == 'R') {
            apply_move(state, 'R');
        } else {
            apply_move(state, 'T');
            apply_move(state, 'R');
        }
    }
    int moves = 0;
    while (!state.empty()) {
        if (state.back() == 'R') {
            apply_move(state, 'R');
        } else {
            apply_move(state, 'T');
            apply_move(state, 'R');
        }
        ++moves;
    }
    cout << moves << '\n';
}
int main() {
    ios::sync_with_stdio(false);
    for (int i = 0; i < 10; i++) {
        do_testcase();
    }
}
